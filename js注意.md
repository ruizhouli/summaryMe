1.	js中的连等是从左往右依次连等
2.	switch中括号中的要和case值全等(=== 值类型都要相等)，在switch的表达式和case的表达式是使用 === 严格相等运算符进行比较的
3.	在变量提升中if语句中的方法 要首先将其改写为 定义式 （var fun = function (){}）
4.	作用域及作用域链中函数的上级作用域只和函数的定义位置有关和函数在哪执行无关 并且自执行函数不会进行预解析
5.	在函数局部变量提升的过程中，如果没有传实参 且局部作用域也没有通过var来声明 那么就会从上级作用域去查找此变量。
6.	我们可以说变量对象包含了活动对象，活动对象就是作用域链上正在被执行和引用的变量对象。我们从活动对象的名称中也能看出 “执行、运行、激活” 等意味。你可以这样理解，整个代码的运行总有一个起始的对象吧，不管这个起始是变量还是函数，总要有一个称呼，虽然我们把执行环境中的变量和函数的总称叫做变量对象，但这不能反映代码的动态性，为了区别于普通的变量对象，我们创造了活动对象的概念。
7.	For of 和for in  for...of 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 for...of 循环，以替代 for...in 和 forEach() ，并支持新的迭代协议。for...of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等，但是for of不能便利普通的对象。 For of 中的i值为每一项的属性值而forin中的i值为每一项的属性名(索引)
8.	在构造函数的原型中，要使用this来代替这个构造函数所实例化的对象，方便
9.	找对象中的key值和value值可以使用Object.keys()和Object.values()其返回值是一个数组
10.	在JavaScript语言中，()里面不能包含语句（只能是表达式），所以解析器在解析到function关键字的时候，会把它们当作function表达式，而不是正常的函数声明。
11.	立即执行函数不会进行预解析
12.	Set的用法
  定义：类似于数组的结构，且成员都是唯一的，且不能重复
	  声明：const set = new Set(arr)
属性：constructor：构造函数，返回Set size:返回成员的总数 
方法：add()返回实例  delete()返回布尔值 has()返回布尔值 clear()清空所有成员 keys()返回以属性值为遍历器的对象 values()返回以属性值为遍历器的对象  entries()返回以属性值和属性值遍历的对象 forEach()遍历对象中的属性值 无返回值
13.	在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。
14.	原生js的灵魂之问：https://juejin.im/post/5dac5d82e51d45249850cd20
15.	JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。
16.	驼峰命名法：(1)全部小写 单词与单词之间去下划线分隔
           (2)大驼峰：每个单词首字母都大写       小驼峰：第一个单词的首字母小写，其余每个有意义的单词首字母大写
17.函数中的this与其在哪定义无关，和他在什么情况下调用有关。
18.生命周期：全局变量：除非被显示删除，不然他会一直存在
             局部变量：在自声明起至函数执行完以后被销毁或者是被显示删除
19. 使用对象直接量方式定义的对象，它的构造器（constructor）指向的是Object
 Person.prototype = {
            getName: function () {}
        }
20. 原型对象里有一个叫constructor的属性，它指向自己的构造器（构造函数）所以，一般用constructor属性来获取当前对象的构造函数
21.原型其实就是当前对象的构造器（构造函数），它上面有个prototype属性，这个属性是个对象，里边包含所有后代都可以继承到的方法和属性，这个prototype属性叫做原型对象，我们一般就是跟它打交道。
22.对象都是有函数构造的   引用类型都是对象   Object.prototype确实一个特例——它的__proto__指向的是null，切记切记！
23.执行上下文环境：在执行代码之前要将所有要用到的变量事先拿出来，有的直接赋值，有的用undefined占位
24. 复杂数据类型在隐式转换时会先转成String，然后再转成Number运算
25.valueOf和toString
valueOf返回的数据类型决定是否调用toString，如果返回的类型是数字或者字符串(其实用基础数据类型更准确点)，toString方法就不执行了。
转化成字符串后再调用Number()转化成数字进行比较
26.Promise
    因为Promise是一个构造函数，所以我们使用了new操作符来创建promise
    构造函数Promise的参数是一个函数（暂时叫它func），这个函数（func）有两个参数resolve和reject，它们分别是两个函数，这两个函数的作用就是将promise的状态从pending（等待）转换为resolved（已解决）或者从pending（等待）转换为rejected（已失败）。
    创建后的promise有一些方法，then和catch。当然我们也可以人为的在Promise函数上添加一些满足我们自己需求的方法，方便每一个promise对象使用。
Promise对象可以通过使用then方法将上一步返回的结果获取过来（不管是resolved还是rejected），可以通过使用catch方法捕获Promise对象在使用catch之前的异常。
27.使用 bind 方法进行上下文的改变，bind 方法与 call 和 apply有着本质的不同，其不同点是，bind()函数返回的是一个新的函数，即方法，而后两者则都是立即执行函数，使用的时候即调用了该函数，返回方法操作的结果。
并且，使用 bind()方法创建的 上下文，其为永久的上下文环境，不可修改，即使是使用 call 或者 apply方法，也无法修改 this 所指向的值。
28.类声明和函数声明的区别
 - 1.函数声明可以被变量提升，类声明不能被提升
 - 2.类声明中代码会强制的运行在严格模式下
 - 3.类中的所有方法都是不可枚举的，而在自定义类型中，可通过Object.defineProperty(),手工指定不可枚举的属性，每个类都有一个construct方法
 - 4.只能使用new来调用类中的构造函数
 - 5.不能在类中修改类名
29.在用class声明时里面必须要有constructor(构造函数)方法，如果没有，js引擎会自动的添加一个空的constructor方法
30. constructor方法是class的构造方法，在class实例化对象时（即new一个对象时）会自动调用构造方法，并且默认返回实例对象（this），当然你完全可以返回另外一个对象。
31.class的静态方法：1.定义class的非静态方法是不用加上function关键字，也不需要用逗号隔开，用了反而会报错，而这些普通的方法(非静态方法)在实例化对象时会被实例继承2.定义class静态方法：需要在方法名前使用static关键字，这样的方法不会被实例所继承，但是它可以被类直接使用3.静态方法可以与非静态方法重名，非静态方法中的this直接指向实例，而静态方法中的this指向的是类4. 非静态方法中，不能直接使用this关键字来访问静态方法，而是要用类名来调用。如果静态方法包含this关键字，这个this指的是类，而不是实例。5. 另外提一点，class的方法名可以用变量来命名6. 类的所有方法都定义在类的prototype属性上面
32.关于 [1,2,3]map(parseInt)问题的解析
     parseInt()的定义是解析一个字符串，并返回一个整数，当参数radix的值为0时或没有设置改参数是，parseInt会根据string来判断数字的基数,
	如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。
    如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。
    如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。
 arr.map(parseInt)含义为对数组numbers的每一项调用parseIne()方法，传入的参数为每一项的值和该值的索引。        
 parseInt(string,radix)
 string: 必须，要被解析的字符串
 radix：可选。表示要解析的数字基数，介于2-36之间。
[‘1’，‘2’，‘3’].map(parseInt)等价于[‘1’，‘2’，‘3’].map（（item,index）=>parseInt(item,index)）

33.for  一般用在数组或者类数组或者字符串(一般是知道长度且知道什么时候结束)
   for in 一般循环对象   (性能比较低 因为枚举的时候会枚举原型链上)
   while  不知道具体的条件或者是模糊的条件
   
34. Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
	Object.assign(target, ...sources)  返回值是目标对象
target
目标对象。
sources
源对象。

35.在正则表达式中使用变量
var str = "variate";//定义变量
var reg = new RegExp(str,"g")//定义正则表达式;
var  myStr = "this is variate";
myStr.replace(reg,'changing now!');
36.return ++问题
return n++;实际上就是return n;n=n+1;但是由于在一个有返回 值得方法中在return之后的语句的语句将不会再次执行，因为涉及到变量的值是否被修改，所以可以简单的理解为在局部变量上使用时的结果就是return n++;===return n;而在全局变量上使用时， 它就是return n++;===(return n;n=n+1;)。



